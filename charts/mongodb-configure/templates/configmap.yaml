apiVersion: v1
kind: ConfigMap
metadata:
  name: setup-mongodb
  namespace: {{ .Release.Namespace }}
data:
  scopes.yml: |
    # Scopes Configuration for MCP Gateway Registry
    #
    # This file defines three main top-level groups:
    # 1. UI-Scopes: Agent registry permissions (list, get, publish, modify, delete agents) and MCP service access
    # 2. group_mappings: Maps Keycloak groups to scope names
    # 3. Individual group scopes: Detailed MCP server method/tool access for each group
    #
    # Each group has two types of permissions:
    # - Agent permissions: Actions on agent resources (list_agents, get_agent, publish_agent, modify_agent, delete_agent)
    # - MCP server permissions: Methods and tools accessible on specific MCP servers (currenttime, mcpgw, fininfo, etc.)
    #
    # To add a new group, follow these three steps:
    # 1. Add to UI-Scopes: Define agent and service permissions (what agents/services the group can access)
    # 2. Add to group_mappings: Map the Keycloak group name to the internal scope name
    # 3. Add individual group scope entry: Define detailed MCP server methods/tools and agent actions for the group

    # ==================== UI-SCOPES ====================
    # Define agent registry permissions and service listing rights for each group
    UI-Scopes:
      # Admin user for MCP registry (highest privileges)
      mcp-registry-admin:
        list_agents:
          - all
        get_agent:
          - all
        publish_agent:
          - all
        modify_agent:
          - all
        delete_agent:
          - all
        list_service:
          - all
        register_service:
          - all
        health_check_service:
          - all
        toggle_service:
          - all
        modify_service:
          - all

      # Registry admin group (wildcard access to all agents and services)
      registry-admins:
        list_agents:
          - all
        get_agent:
          - all
        publish_agent:
          - all
        modify_agent:
          - all
        delete_agent:
          - all
        list_service:
          - all
        register_service:
          - all
        health_check_service:
          - all
        toggle_service:
          - all
        modify_service:
          - all

      # LOB1 (Line of Business 1): Restricted to code-reviewer and test-automation agents
      registry-users-lob1:
        list_agents:
          - /code-reviewer
          - /test-automation
        get_agent:
          - /code-reviewer
          - /test-automation
        publish_agent:
          - /code-reviewer
          - /test-automation
        modify_agent:
          - /code-reviewer
          - /test-automation
        delete_agent:
          - /code-reviewer
          - /test-automation
        list_service:
          - currenttime
          - mcpgw
        health_check_service:
          - currenttime
          - mcpgw

      # LOB2 (Line of Business 2): Restricted to data-analysis and security-analyzer agents
      registry-users-lob2:
        list_agents:
          - /data-analysis
          - /security-analyzer
        get_agent:
          - /data-analysis
          - /security-analyzer
        publish_agent:
          - /data-analysis
          - /security-analyzer
        modify_agent:
          - /data-analysis
          - /security-analyzer
        delete_agent:
          - /data-analysis
          - /security-analyzer
        list_service:
          - realserverfaketools
          - mcpgw
          - fininfo
        health_check_service:
          - realserverfaketools
          - mcpgw
          - fininfo

    # ==================== GROUP MAPPINGS ====================
    # Maps Keycloak groups to internal scope group names
    group_mappings:
      mcp-registry-admin:
        - mcp-registry-admin
        - mcp-servers-unrestricted/read
        - mcp-servers-unrestricted/execute
      registry-admins:
        - registry-admins
      registry-users-lob1:
        - registry-users-lob1
      registry-users-lob2:
        - registry-users-lob2
      # Add mappings for the actual Keycloak groups
      mcp-registry-developer:
        - registry-admins  # Map developers to admin scope
      mcp-registry-operator:
        - registry-admins  # Map operators to admin scope  
      mcp-registry-user:
        - registry-users-lob1  # Map users to LOB1 scope
      mcp-servers-restricted:
        - registry-users-lob1  # Map restricted users to LOB1
      mcp-servers-unrestricted:
        - mcp-servers-unrestricted/read
        - mcp-servers-unrestricted/execute

    # ==================== MCP SERVER SCOPES ====================
    # Unrestricted read access: Wildcard access to all servers with all methods and tools
    mcp-servers-unrestricted/read:
      - server: '*'
        methods:
          - initialize
          - notifications/initialized
          - ping
          - tools/list
          - tools/call
          - resources/list
          - resources/templates/list
          - GET
        tools: '*'

    # Unrestricted execute access: Full CRUD operations on all servers (POST, PUT, DELETE in addition to read)
    mcp-servers-unrestricted/execute:
      - server: '*'
        methods:
          - initialize
          - notifications/initialized
          - ping
          - tools/list
          - tools/call
          - resources/list
          - resources/templates/list
          - GET
          - POST
          - PUT
          - DELETE
        tools: '*'

    # LOB1 Group Scope: Read-only access to API; currenttime and mcpgw servers; code-reviewer and test-automation agents
    registry-users-lob1:
      - server: api
        methods:
          - initialize
          - GET
      - server: currenttime
        methods:
          - initialize
          - notifications/initialized
          - ping
          - tools/list
          - tools/call
          - resources/list
          - resources/templates/list
        tools:
          - current_time_by_timezone
      - server: mcpgw
        methods:
          - initialize
          - notifications/initialized
          - ping
          - tools/list
          - tools/call
          - resources/list
          - resources/templates/list
        tools:
          - intelligent_tool_finder
      - agents:
          actions:
            - action: list_agents
              resources:
                - /code-reviewer
                - /test-automation
            - action: get_agent
              resources:
                - /code-reviewer
                - /test-automation
            - action: publish_agent
              resources:
                - /code-reviewer
                - /test-automation
            - action: modify_agent
              resources:
                - /code-reviewer
                - /test-automation
            - action: delete_agent
              resources:
                - /code-reviewer
                - /test-automation

    # LOB2 Group Scope: Read-only access to API; realserverfaketools, mcpgw, fininfo servers; data-analysis and security-analyzer agents
    registry-users-lob2:
      - server: api
        methods:
          - initialize
          - GET
      - server: realserverfaketools
        methods:
          - initialize
          - notifications/initialized
          - ping
          - tools/list
          - tools/call
          - resources/list
          - resources/templates/list
        tools:
          - quantum_flux_analyzer
          - neural_pattern_synthesizer
          - hyper_dimensional_mapper
      - server: mcpgw
        methods:
          - initialize
          - notifications/initialized
          - ping
          - tools/list
          - tools/call
          - resources/list
          - resources/templates/list
        tools:
          - intelligent_tool_finder
      - server: fininfo
        methods:
          - initialize
          - notifications/initialized
          - ping
          - tools/list
          - tools/call
          - resources/list
          - resources/templates/list
        tools:
          - get_stock_aggregates
          - print_stock_data
      - agents:
          actions:
            - action: list_agents
              resources:
                - /data-analysis
                - /security-analyzer
            - action: get_agent
              resources:
                - /data-analysis
                - /security-analyzer
            - action: publish_agent
              resources:
                - /data-analysis
                - /security-analyzer
            - action: modify_agent
              resources:
                - /data-analysis
                - /security-analyzer
            - action: delete_agent
              resources:
                - /data-analysis
                - /security-analyzer

    # Admin Group Scope: Unrestricted access to all servers with wildcard; unrestricted access to all agents
    registry-admins:
      - server: '*'
        methods:
          - all
        tools:
          - all
      - agents:
          actions:
            - action: list_agents
              resources:
                - all
            - action: get_agent
              resources:
                - all
            - action: publish_agent
              resources:
                - all
            - action: modify_agent
              resources:
                - all
            - action: delete_agent
              resources:
                - all

    # MCP Registry Admin Scope: UI-only scope for registry administration (no server access needed)
    mcp-registry-admin:
      - server: '*'
        methods:
          - all
        tools:
          - all
      - agents:
          actions:
            - action: list_agents
              resources:
                - all
            - action: get_agent
              resources:
                - all
            - action: publish_agent
              resources:
                - all
            - action: modify_agent
              resources:
                - all
            - action: delete_agent
              resources:
                - all

  wait.py: |
    import pymongo
    import os
    import time
    import sys

    MONGO_HOST = os.getenv("DOCUMENTDB_HOST", "mongodb")
    MONGO_PORT = os.getenv("DOCUMENTDB_PORT", "27017")
    REPLICA_SET = os.getenv("DOCUMENTDB_REPLICA_SET", "rs0")
    USERNAME = os.getenv("DOCUMENTDB_USERNAME", "")
    PASSWORD = os.getenv("DOCUMENTDB_PASSWORD", "")

    def wait_for_mongodb():
        while True:
            try:
                # First check basic connectivity
                client = pymongo.MongoClient(f"mongodb://{USERNAME}:{PASSWORD}@{MONGO_HOST}:{MONGO_PORT}/?authMechanism=SCRAM-SHA-256&authSource=admin",
                                             serverSelectionTimeoutMS=5000,
                                             connectTimeoutMS=5000)
                client.admin.command('ping')
                print("MongoDB is accepting connections. Checking replica set status...")

                # Check replica set status
                status = client.admin.command('replSetGetStatus')

                if status['ok'] != 1:
                    print("Replica set not initialized yet")
                    time.sleep(10)
                    continue

                ready_members = [m for m in status['members'] if m['state'] in [1, 2]]  # PRIMARY or SECONDARY
                total_members = len(status['members'])

                if len(ready_members) == total_members:
                    print(f"All replica set members are ready ({len(ready_members)}/{total_members})")
                    break
                else:
                    print(f"Waiting for replica set members: {len(ready_members)}/{total_members} ready")
                    time.sleep(10)

            except Exception as e:
                print(f"MongoDB not ready yet: {e}")
                time.sleep(5)
            finally:
                try:
                    client.close()
                except:
                    pass

    wait_for_mongodb()
    print("MongoDB replica set is fully ready!")

  script.py: |
    #!/usr/bin/env python3
    """
    Initialize MongoDB CE for local development.

    This script:
    1. Initializes replica set (rs0)
    2. Creates collections and indexes
    3. Loads scopes from scopes.yml

    Usage:
        python init-mongodb-ce.py
    """

    import asyncio
    import logging
    import os
    import sys
    import time
    import yaml
    from typing import Optional

    from motor.motor_asyncio import AsyncIOMotorClient
    from pymongo import ASCENDING
    from pymongo.errors import ServerSelectionTimeoutError, OperationFailure


    # Configure logging with basicConfig
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s,p%(process)s,{%(filename)s:%(lineno)d},%(levelname)s,%(message)s",
    )
    logger = logging.getLogger(__name__)


    # Collection names
    COLLECTION_SERVERS = "mcp_servers"
    COLLECTION_AGENTS = "mcp_agents"
    COLLECTION_SCOPES = "mcp_scopes"
    COLLECTION_EMBEDDINGS = "mcp_embeddings_1536"
    COLLECTION_SECURITY_SCANS = "mcp_security_scans"
    COLLECTION_FEDERATION_CONFIG = "mcp_federation_config"


    def _get_config_from_env() -> dict:
        """Get MongoDB CE configuration from environment variables."""
        return {
            "host": os.getenv("DOCUMENTDB_HOST", "mongodb"),
            "port": int(os.getenv("DOCUMENTDB_PORT", "27017")),
            "database": os.getenv("DOCUMENTDB_DATABASE", "mcp_registry"),
            "namespace": os.getenv("DOCUMENTDB_NAMESPACE", "default"),
            "scopes_file": os.getenv("SCOPES_FILE", "/app/config/scopes.yml"),
            "username": os.getenv("DOCUMENTDB_USERNAME", ""),
            "password": os.getenv("DOCUMENTDB_PASSWORD", ""),
            "replicaset": os.getenv("DOCUMENTDB_REPLICA_SET", "rs0"),
        }


    def _initialize_replica_set(
        host: str,
        port: int,
        username: str,
        password: str,
    ) -> None:
        """Initialize MongoDB replica set using pymongo (synchronous)."""
        from pymongo import MongoClient

        logger.info("Initializing MongoDB replica set...")

        try:
            # Connect without replica set for initialization
            client = MongoClient(
                f"mongodb://{username}:{password}@{host}:{port}/?authMechanism=SCRAM-SHA-256&authSource=admin",
                serverSelectionTimeoutMS=5000,
                directConnection=True,
            )

            # Check if already initialized
            try:
                status = client.admin.command("replSetGetStatus")
                logger.info("Replica set already initialized")
                client.close()
                return
            except OperationFailure as e:
                if "no replset config has been received" in str(e).lower():
                    # Not initialized, proceed
                    pass
                else:
                    raise

            # Initialize replica set
            config = {
                "_id": "rs0",
                "members": [
                    {"_id": 0, "host": f"{host}:{port}"}
                ]
            }

            result = client.admin.command("replSetInitiate", config)
            logger.info(f"Replica set initialized: {result}")
            client.close()

            # Wait for replica set to elect primary
            logger.info("Waiting for replica set to elect primary...")
            time.sleep(10)

        except Exception as e:
            logger.error(f"Error initializing replica set: {e}")
            raise


    async def _create_standard_indexes(
        collection,
        collection_name: str,
        namespace: str,
    ) -> None:
        """Create standard indexes for collections."""
        full_name = f"{collection_name}_{namespace}"

        if collection_name == COLLECTION_SERVERS:
            # Note: path is stored as _id, so no separate path index needed
            await collection.create_index([("enabled", ASCENDING)])
            await collection.create_index([("tags", ASCENDING)])
            await collection.create_index([("manifest.serverInfo.name", ASCENDING)])
            logger.info(f"Created indexes for {full_name}")

        elif collection_name == COLLECTION_AGENTS:
            # Note: path is stored as _id, so no separate path index needed
            await collection.create_index([("enabled", ASCENDING)])
            await collection.create_index([("tags", ASCENDING)])
            await collection.create_index([("card.name", ASCENDING)])
            logger.info(f"Created indexes for {full_name}")

        elif collection_name == COLLECTION_SCOPES:
            # No additional indexes needed - scopes use _id as primary key
            # group_mappings is an array, not indexed
            logger.info(f"Created indexes for {full_name}")

        elif collection_name == COLLECTION_EMBEDDINGS:
            # Note: path is stored as _id, so no separate path index needed
            await collection.create_index([("entity_type", ASCENDING)])
            logger.info(f"Created indexes for {full_name} (vector search via app code)")

        elif collection_name == COLLECTION_SECURITY_SCANS:
            await collection.create_index([("server_path", ASCENDING)])
            await collection.create_index([("scan_status", ASCENDING)])
            await collection.create_index([("scanned_at", ASCENDING)])
            logger.info(f"Created indexes for {full_name}")

        elif collection_name == COLLECTION_FEDERATION_CONFIG:
            await collection.create_index([("registry_name", ASCENDING)], unique=True)
            await collection.create_index([("enabled", ASCENDING)])
            logger.info(f"Created indexes for {full_name}")


    async def _load_scopes_from_yaml(
        db,
        namespace: str,
        scopes_file: str,
    ) -> None:
        """Load scopes from YAML file into MongoDB.

        Uses same logic as load-scopes.py to parse scopes.yml structure:
        - group_mappings: Keycloak group to scope name mappings
        - UI-Scopes: UI permissions for each scope
        - Individual scope entries: Server access lists for each scope
        """
        logger.info(f"Loading scopes from {scopes_file}")

        # Check if file exists
        if not os.path.exists(scopes_file):
            logger.warning(f"Scopes file not found: {scopes_file}")
            logger.warning("Scopes will not be loaded. You can load them later using load-scopes.py")
            return

        # Read YAML file
        with open(scopes_file, "r") as f:
            scopes_data = yaml.safe_load(f)

        if not scopes_data:
            logger.warning(f"No scopes data found in {scopes_file}")
            return

        collection_name = f"{COLLECTION_SCOPES}_{namespace}"
        collection = db[collection_name]

        # Extract group mappings and UI scopes
        group_mappings = scopes_data.get("group_mappings", {})
        ui_scopes = scopes_data.get("UI-Scopes", {})

        # Process each scope group
        scope_groups = []
        for key, value in scopes_data.items():
            # Skip the top-level keys
            if key in ["group_mappings", "UI-Scopes"]:
                continue

            # This is a scope group
            scope_name = key
            server_access = value if isinstance(value, list) else []

            # Build the scope document
            scope_doc = {
                "_id": scope_name,
                "group_mappings": [],
                "server_access": server_access,
                "ui_permissions": {},
            }

            # Add group mappings for this scope
            for keycloak_group, scope_names in group_mappings.items():
                if scope_name in scope_names:
                    scope_doc["group_mappings"].append(keycloak_group)

            # Add UI permissions for this scope
            if scope_name in ui_scopes:
                scope_doc["ui_permissions"] = ui_scopes[scope_name]

            scope_groups.append(scope_doc)

        # Insert scopes into MongoDB
        if scope_groups:
            logger.info(f"Inserting {len(scope_groups)} scope groups into {collection_name}")

            # Clear existing scopes first
            await collection.delete_many({})

            for scope_doc in scope_groups:
                try:
                    # Use update_one with upsert to avoid duplicate key errors
                    result = await collection.update_one(
                        {"_id": scope_doc["_id"]},
                        {"$set": scope_doc},
                        upsert=True
                    )

                    if result.upserted_id:
                        logger.info(f"Inserted scope: {scope_doc['_id']}")
                    elif result.modified_count > 0:
                        logger.info(f"Updated scope: {scope_doc['_id']}")

                except Exception as e:
                    logger.error(f"Failed to insert scope {scope_doc['_id']}: {e}")

            logger.info(f"Successfully loaded {len(scope_groups)} scopes")
        else:
            logger.warning("No scope groups found to insert")


    async def _initialize_mongodb_ce() -> None:
        """Main initialization function."""
        config = _get_config_from_env()

        logger.info("=" * 60)
        logger.info("MongoDB CE Initialization for MCP Gateway")
        logger.info("=" * 60)
        logger.info(f"Host: {config['host']}:{config['port']}")
        logger.info(f"Database: {config['database']}")
        logger.info(f"Namespace: {config['namespace']}")
        logger.info(f"Scopes file: {config['scopes_file']}")
        logger.info("")

        # Wait for MongoDB to be ready
        logger.info("Waiting for MongoDB to be ready...")
        time.sleep(10)

        # Initialize replica set (synchronous)
        _initialize_replica_set(config["host"], config["port"], config["username"], config["password"])

        # Connect with motor for async operations
        connection_string = f"mongodb://{config['username']}:{config['password']}@{config['host']}:{config['port']}/{config['database']}?replicaSet={config['replicaset']}&authMechanism=SCRAM-SHA-256&authSource=admin"
        try:
            client = AsyncIOMotorClient(
                connection_string,
                serverSelectionTimeoutMS=10000,
            )

            # Verify connection
            await client.admin.command("ping")
            logger.info("Connected to MongoDB successfully")

            db = client[config["database"]]
            namespace = config["namespace"]

            # Create collections and indexes
            logger.info("Creating collections and indexes...")

            collections = [
                COLLECTION_SERVERS,
                COLLECTION_AGENTS,
                COLLECTION_SCOPES,
                COLLECTION_EMBEDDINGS,
                COLLECTION_SECURITY_SCANS,
                COLLECTION_FEDERATION_CONFIG,
            ]

            for coll_name in collections:
                full_name = f"{coll_name}_{namespace}"

                # Check if collection already exists
                existing_collections = await db.list_collection_names()

                if full_name in existing_collections:
                    logger.info(f"Collection {full_name} already exists, skipping creation")
                else:
                    logger.info(f"Creating collection: {full_name}")
                    await db.create_collection(full_name)

                # Create indexes (idempotent - MongoDB handles duplicates)
                collection = db[full_name]
                await _create_standard_indexes(collection, coll_name, namespace)

            # Load scopes
            await _load_scopes_from_yaml(db, namespace, config["scopes_file"])

            logger.info("")
            logger.info("=" * 60)
            logger.info("MongoDB CE Initialization Complete!")
            logger.info("=" * 60)
            logger.info("Collections created:")
            for coll_name in collections:
                if coll_name == COLLECTION_EMBEDDINGS:
                    logger.info(f"  - {coll_name}_{namespace} (with vector search)")
                else:
                    logger.info(f"  - {coll_name}_{namespace}")
            logger.info("")
            logger.info("To use MongoDB CE:")
            logger.info("  export STORAGE_BACKEND=mongodb-ce")
            logger.info("  docker-compose up registry")
            logger.info("")
            logger.info("Or for AWS DocumentDB:")
            logger.info("  export STORAGE_BACKEND=documentdb")
            logger.info("  docker-compose up registry")
            logger.info("=" * 60)

            client.close()

        except ServerSelectionTimeoutError as e:
            logger.error(f"Failed to connect to MongoDB: {e}")
            logger.error("Make sure MongoDB is running and accessible")
            sys.exit(1)
        except Exception as e:
            logger.error(f"Error during initialization: {e}")
            raise


    def main() -> None:
        """Entry point."""
        asyncio.run(_initialize_mongodb_ce())


    if __name__ == "__main__":
        main()
